/**
  ******************************************************************************
  * \file    uart_led.c
  * \author  Александр Смирнов
  * \version 1.0.2
  * \date    18.05.2025
  * \brief   Программа на языке C для учебного стенда на базе
  *          STM32F072RBT6 в среде разработки Keil uVision 5.
  *          Подключение библиотек поддержки МК STM32F072RBT6 осуществляется
  *          средствами IDE Keil через менеджер пакетов Run-Time Environment (RTE).
  *          Разработать программу, обеспечивающую управление светодиодами
  *          через командный интерфейс.
  *          При вводе команды "LED1" загорается светодиод D1,
  *          команды "LED2" загорается светодиод D2, и так далее.
  *          Если введена неизвестная команда, то на терминал выводится слово
  *          "ERROR".
  *          Программа работает в режиме 0 учебного стенда (S1 = 0, S2 = 0).
  ******************************************************************************
  */

/* Подключение заголовочного файла с макроопределениями всех регистров специальных
   функций МК STM32F072RBT6. */
#include <stm32f0xx.h>

/* Функция инициализации светодиодов D1-D8 */
void leds_init(void)
{
    /* Включение тактирования порта C */
    RCC->AHBENR |= RCC_AHBENR_GPIOCEN;

    /* Настройка на вывод линий PC0 - PC7 (D1 - D8) */
    GPIOC->MODER |= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER1_0 | GPIO_MODER_MODER2_0 |
                    GPIO_MODER_MODER3_0 | GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0 |
                    GPIO_MODER_MODER6_0 | GPIO_MODER_MODER7_0;
}

/* Функция включения светодиодов */
void led_set(uint8_t led)
{
    /* Записываем в регистр данных порта C новое состояние светодиодов.
       Номер бита соответствует номеру светодиода: бит 0 - D1, бит 1 - D2 и
       так далее */
    GPIOC->ODR = led;
}

/* Функция инициализации приемника/передатчика USART2 */
void usart_init(void)
{
    /* Включить тактирование порта A */
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

    /* Включить тактирование USART2 */
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    /* Включить альтернативной функцию №1 (USART2) на линиях PA2 и PA3 */
    GPIOA->AFR[0] |= (1 << GPIO_AFRL_AFRL2_Pos) | (1 << GPIO_AFRL_AFRL3_Pos);

    /* Включить режим альтернативной функции на линиях PA2 и PA3 */
    GPIOA->MODER |=
        GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;

    /* Установить коэффициент деления.
       BRR = fbus / baudrate
       Пусть baudrate = 9600 бод, частота шины fbs = 8 МГц,
       тогда BRR = 8000000 / 9600 */
    USART2->BRR = 8000000 / 9600;
    /* Включить передатчик */
    USART2->CR1 |= USART_CR1_TE;
    /* Включить приемник */
    USART2->CR1 |= USART_CR1_RE;
    /* Включить USART */
    USART2->CR1 |= USART_CR1_UE;

    /* Чтение регистра данных для сброса флагов */
    uint16_t dummy = USART2->RDR;
}

/* Функция передачи байта в бесконечном цикле */
void usart_transmit(uint8_t data)
{
    /* Записать байт в регистр данных */
    USART2->TDR = data;
    /* Ожидание флага окончания передачи TC (Transmission Complete) */
    while(!(USART2->ISR & USART_ISR_TC));
}

/* Функция приема байта в бесконечном цикле */
uint8_t usart_receive(void)
{
    /* Ожидание флага буфер приемника не пуст RXNE (Receiver buffer not empty) */
    while(!(USART2->ISR & USART_ISR_RXNE));
    /* Чтение принятого байта и возврат из функции */
    return USART2->RDR;
}

/* Функция сравнения двух строк.
   Строки представлены в ASCII кодировке.
   Строки являются нуль терминированными - код окончания строки - 0 (ноль).
   В стандартной библиотеке C уже есть функция strcmp.
   В примере для учебных целей показана простейшая реализация
   такой функции. */
int32_t _strncmp(const char s1[], const char s2[], uint32_t n)
{
    uint32_t i = 0;

    while (i < n)
    {
        if (s1[i] != s2[i])
        {
            return (unsigned char)s1[i] - (unsigned char)s2[i];
        }
        if (s1[i] == '\0')
        {
            return 0;
        }
        i++;
    }

    return 0;
}

/* Функция преобразования строки в число.
   В стандартной библиотеке C уже есть функция atoi.
   В примере для учебных целей показана простейшая реализация
   такой функции. */
int32_t _atoi(const char s[])
{
    int32_t n = 0;
    int32_t i = 0;

    while (s[i] != '\0' && s[i] >= '0' && s[i] <= '9')
    {
        n *= 10;
        n += s[i] - '0';
        i++;
    }

    return n;
}

/* Функция передачи строки */
void putstr(char* str)
{
    while (*str != '\0')
    {
        usart_transmit(*str);
        str++;
    }
}

/* Функция main - точка входа в программу */
int main(void)
{
    /* Инициализация светодиодов D1-D8 */
    leds_init();
    /* Инициализация USART */
    usart_init();

    char buf[20] = {0};
    int32_t pos = 0;

    /* Бесконечный цикл */
    while (1)
    {
        char ch = usart_receive();

        /* Наполнение буфера если не нажата клавиша Enter.
           Символ `\r` передается при нажатии клавиши Enter в терминале. */
        if (ch != '\r')
        {
            if (pos < sizeof(buf) - 1)
            {
                buf[pos] = ch;
                pos++;
            }
        }
        else
        {
            /* Сравнение содержимого буфера с командой */
            if (_strncmp(buf, "LED", 3) == 0)
            {
                /* Преобразование строки с номером светодиода в число.
                   Передаем строку со смещение на длину команды LED */
                int32_t n = _atoi(&buf[3]);

                /* Минимальная проверка */
                if (n >= 1 && n <= 8)
                {
                    /* Исполнение команды */
                    led_set(1 << (n - 1));
                }
                else
                {
                    /* Передача строки ERROR.
                    Символ `\n` переводит курсор на новую строку в терминале */
                    putstr("ERROR\n");
                }
            }
            else
            {
                /* Передача строки ERROR */
                putstr("ERROR\n");
            }

            /* Буфер наполняется заново */
            pos = 0;
            /* Очистка буфера */
            for (int32_t i = 0; i < sizeof(buf); i++)
            {
                buf[i] = '\0';
            }
        }
    }
}
