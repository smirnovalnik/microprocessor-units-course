; \file    main.s
; \author  Александр Смирнов
; \version 1.1.0
; \date    12.11.2022
; \brief   Программа на языке Ассемблер (ARM) для среды разработки Keil uVision 5.
;          Задача: Разработать программу реализующую логическую функцию:
;          y =  x5 * ~x3 * ~x0
;
;          Аргумент логической функции имеет размер 8 бит и задается
;          переключателями SW1-SW4. Программа может выводить до 8 логических
;          одновременно.
;          Из-за ограничений учебного стенда 8 битовое слово задается
;          в два шага. На первом шаге выставляются младшие 4 бита аргумента
;          на переключателях SW1-SW4 и по нажатии на кнопку SB1 аргументы
;          записываются в память. На втором шаге выставляются старшие 4 бита
;          аргумента на тех же переключателях SW1-SW4 и по нажатии на кнопку
;          SB2 записываются в память. Итоговое 8 битовое слово
;          отображается на светодиодах D9-D16.
;          Последовательность задания младших и старших битов не важна.
;          По нажатии на кнопку SB3 происходит передача аргументов
;          в подпрограмму Logic_Func через регистр R0.
;          Перед выходом из подпрограммы результат логической
;          сохраняется в самый младщий байт регистра R1. Далее результат (8 бит)
;          выводится на светодиоды D1-D8.
;
;          | SW4  SW3  SW2  SW1  | SW4  SW3  SW2  SW1  |
;          |  x7   x6   x5   x4  |  x3   x2   x1   x0  |   ---->   y = f(X), y -> D1-D8
;          |         SB2         |         SB1         |    SB3
;
;          ВНИМАНИЕ! В ДАННОМ ПРИМЕРЕ РЕЖИМ ОТЛАДКИ НЕ ДОСТУПЕН.
;          ДОСТУПНА ТОЛЬКО ЗАГРУЗКА ПРОГРАММЫ.


            ; Секция с программой
            ; Обязательная секция
            AREA    PROGRAM, CODE, READONLY     ; Указание на расположение программы в памяти
            ENTRY                               ; Указание на точку входа в программу
            ALIGN                               ; Выровнять по слову (4 байта)

            ; Подпрограмма - логическая функция
            ; R0 - аргументы (8 младших бит)
            ; R1 - возвращаемое значение (8 младших бит)
            ; Результат работы функции каждой функции (0 или 1) должен помещаться
            ; в самый младший байт регистра R1 в соответствующую позицию
            ; для последующего отображения на светодиодах.
Logic_Func
            ; НАЧАЛО КОДА ЛОГИЧЕСКОЙ ФУНКЦИИ
            MOVS  R1, #0
            MOVS  R2, #0x20
            TST   R0, R2
            BEQ   Exit
            MOVS  R2, #0x09
            TST   R0, R2
            BNE   Exit
Set_True    MOVS  R1, #1
Exit
            ; КОНЕЦ КОДА ЛОГИЧЕСКОЙ ФУНКЦИИ
            BX    LR

            ; Далее программа, отвечающая за ввод аргументов,
            ; вызов логической фукнции и отображение результата.

            ; Макроопределения
RCC_BASE    EQU   0x40021000         ; Начальный адрес регистров модуля RCC
RCC_AHBENR  EQU   RCC_BASE + 0x14    ; Адрес регистра AHBENR

GPIOA_BASE  EQU   0x48000000         ; Начальный адрес регистров модуля GPIOA
GPIOA_MODER EQU   GPIOA_BASE + 0x00  ; Адрес регистра MODER
GPIOA_PUPDR EQU   GPIOA_BASE + 0x0C  ; Адрес регистра PUPDR
GPIOA_IDR   EQU   GPIOA_BASE + 0x10  ; Адрес регистра IDR

GPIOB_BASE  EQU   0x48000400         ; Начальный адрес регистров модуля GPIOB
GPIOB_PUPDR EQU   GPIOB_BASE + 0x0C  ; Адрес регистра PUPDR
GPIOB_IDR   EQU   GPIOB_BASE + 0x10  ; Адрес регистра IDR

GPIOC_BASE  EQU   0x48000800         ; Начальный адрес регистров модуля GPIOC
GPIOC_MODER EQU   GPIOC_BASE + 0x00  ; Адрес регистра MODER
GPIOC_ODR   EQU   GPIOC_BASE + 0x14  ; Адрес регистра ODR


Reset_Handler
            ; Настройка портов ввода/вывода
            ; Включить тактирование портов A, B и C
            LDR   R0, =RCC_AHBENR   ; Загрузить адрес регистра RCC_AHBENR в R0
            LDR   R1, =((1 << 17) :OR: (1 << 18) :OR: (1 << 19)) ; Загрузить маску портов A, B и C в R1
            STR   R1, [R0]          ; Сохранить R1 по адресу R0

            ; Вывод PA13 после сброса находится в режиме альтернативной функции
            ; SWDIO с включенной подтяжкой к питанию.
            ; Вывод PA14 - в режиме альтернативной функции SWCLK с включенной подтяжкой к земле.
            ; Выключение альтернативной функции позволит использовать PA13(SW3) и PA14(SW4),
            ; но отладка будет не доступна.
            LDR   R0, =GPIOA_MODER  ; Загрузить адрес регистра GPIOC_MODER в R0
            LDR   R1, =0x0          ; Загрузить код 0 в R1
            STR   R1, [R0]          ; Сохранить R1 по адресу R0

            ; Включение подтягивающих резисторов для PA11(SW1), PA12(SW2), PA13(SW3), PA14(SW4)
            LDR   R0, =GPIOA_PUPDR  ; Загрузить адрес регистра GPIOA_PUPDR в R0
            LDR   R1, =((1 << (2 * 11)) :OR: (1 << (2 * 12)) :OR: (1 << (2 * 13)) :OR: (1 << (2 * 14))) ; Загрузить маску в R1
            STR   R1, [R0]          ; Сохранить R1 по адресу R0

            ; Включение подтягивающих резисторов для PB4(SB1), PB5(SB2), PB6(SB3)
            LDR   R0, =GPIOB_PUPDR  ; Загрузить адрес регистра GPIOB_PUPDR в R0
            LDR   R1, =((1 << (2 * 4)) :OR: (1 << (2 * 5)) :OR: (1 << (2 * 6))) ; Загрузить маску в R1
            STR   R1, [R0]          ; Сохранить R1 по адресу R0

            ; Настроить линии PC0(D1) и PC8(D9)-PC15(D16) на вывод
            LDR   R0, =GPIOC_MODER  ; Загрузить адрес регистра GPIOC_MODER в R0
            LDR   R1, =0x55555555   ; Загрузить код 0x55555555 в R1
            STR   R1, [R0]          ; Сохранить R1 по адресу R0

            ; R0 - аргумент логической функции
            MOVS  R0, #0            ; Очистить R0
            ; Основной цикл программы
Main_Loop
            ; Вывести на D9-D16 регистр R0 (аргументы функции)
            LDR   R1, =GPIOC_ODR    ; Загрузить адрес регистра вывода порта C
            MOVS  R2, R0            ; Скопировать R0 в R2
            LSLS  R2, R2, #8        ; Сдвинуть в старший байт
            STR   R2, [R1]          ; Записать R2 в регистр вывода порта C

            ; Загрузить состояние SW1-SW4 в R2
            LDR   R1, =GPIOA_IDR    ; Загрузить адрес регистра ввода порта A
            LDR   R2, [R1]          ; Прочитать состояние порта A (SW1-SW4)
            LSRS  R2, R2, #11       ; Сдвинуть в младщие позиции
            MOVS  R1, #0xF          ; Загрузить маску младших битов
            ANDS  R2, R2, R1        ; Сбросить биты по маске

            ; Загрузить состояние SB1-SB4 в R3
            LDR   R1, =GPIOB_IDR    ; Загрузить адрес регистра ввода порта B
            LDR   R3, [R1]          ; Прочитать состояние порта B (SB1-SB3)
            LSRS  R3, R3, #4        ; Сдвинуть в младщие позиции
            MOVS  R1, #7            ; Загрузить маску младших битов
            ANDS  R3, R3, R1        ; Сбросить биты по маске

            ; Сохранить 4 младших бита в R0 по нажанию SB1
            MOVS  R4, #0x1          ; Загрузить маску PB4(SB1)
            TST   R3, R4            ; Проверить состояние бита
            BNE   Not_SB1           ; Переход если кнопка не нажата
            MOVS  R4, #0xF          ; Загрузить маску 4-х младших битов
            BICS  R0, R0, R4        ; Очистить 4 младших бита
            ORRS  R0, R0, R2        ; Объединить 4 младщих бита R0 и R2
            B     Main_Loop

Not_SB1
            ; Сохранить 4 старших бита в R0 по нажанию SB2
            MOVS  R4, #0x2          ; Загрузить маску PB5(SB2)
            TST   R3, R4            ; Проверить состояние бита
            BNE   Not_SB2           ; Переход если кнопка не нажата
            MOVS  R4, #0xF0         ; Загрузить маску 4-х старших битов
            BICS  R0, R0, R4        ; Очистить 4 старших бита
            LSLS  R2, R2, #4        ; Сдвинуть биты в старшую позицию
            ORRS  R0, R0, R2        ; Поместить в R0 4 младщих бита
            B     Main_Loop

Not_SB2
            ; Вызвать логическую функцию по нажатию SB3
            MOVS  R4, #0x4          ; Загрузить маску PB6(SB3)
            TST   R3, R4            ; Проверить состояние бита
            BNE   Main_Loop         ; Переход если кнопка не нажата

            PUSH  {R0}              ; Сохранить регистр R0 на стеке
            BL    Logic_Func        ; Вызвать подпрограмму с логической функцией
            POP   {R0}              ; Восстановить из стека регистр R0

            LDR   R2, =GPIOC_ODR    ; Загрузить адрес регистра вывода порта C
            STR   R1, [R2]          ; Записать в PC0-PC7(D1-D8) результаты функций

            B     Main_Loop

            ALIGN                   ; Выровнять по слову (4 байта)

            ; Секция с таблицей векторов прерываний.
            AREA    RESET, DATA, READONLY ; Указание на расположение векторов прерываний
            EXPORT  Vectors         ; Экспорт метки Vectors для компоновщика
Vectors
            DCD     0x20004000      ; Начало стека (последний адрес ОЗУ)
            DCD     Reset_Handler   ; Вектор сброса (начало программы)

            END                     ; Команда транслятору об окончании текста программы
