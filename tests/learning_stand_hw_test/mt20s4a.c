/**
  ******************************************************************************
  * \file    mt20s4a.с
  * \author  Александр Смирнов
  * \version 1.0.0
  * \date    02.01.2021
  * \brief   Драйвер ЖКИ модуля MT20S4A. 20 x 4 символов.
  *          Графический контроллер КБ1013ВГ6(HD44780).
  ******************************************************************************
*/

#include "mt20s4a.h"

void _delay(uint32_t ticks)
{
    for (int32_t i = 0; i < (uint32_t)ticks * 2; i++)
        ;
}

void _delay_ms(uint32_t ticks)
{
    _delay(ticks * 1000);
}

/*Максимальное количество чтений флага готовности.*/
#define CYCLE_TIMEOUT   5000

/*Функция проверки флага занятости.*/
void ctrl_ready ()
{
    #ifdef READ_BF
    uint16_t i;
    uint8_t busy;

    RS_IR();                /*Обращение к регистру данных.*/
    RW_SET();               /*Подача сигнала чтения.*/
    for (i = 0; i < CYCLE_TIMEOUT; i++)
    {
        E_SET();            /*Строб.*/
        _delay(1);          /*Задержка выставления данных контроллером >120нс.*/
        busy = BF;
        E_CLR();            /*Строб.*/
        _delay(1);          /*Задержка между операциями чтения >250нс.*/
        _delay(1);
        E_SET();
        _delay(1);
        E_CLR();
        NOP();
        if (busy == 0) break;   /*Проверки бита готовности.*/
    }
    #else
    /* Время выполнения всех команд кроме clear disp равно 40 мкс */
    _delay(40);
    #endif
}

/*Функция записи команд в графический контроллер.
Записываемые данные определяются аргументом data.*/
void cmd_write (unsigned char data)
{
    ctrl_ready(); /*Проверка флага занятости.*/

    /*Запись  в регистр команд.*/
    RS_IR();        /*Выбор регистра команд.*/
    RW_CLR();       /*Подача сигнала записи.*/

    /*Старшая декада*/
    E_SET();        /*Строб.*/
    DATA &= 0xFF00;
    DATA |= 0x00FF & data;  /*Вывод в порт данных для записи.*/
    _delay(1);              /*Задержка >230нс(минимальная длительность строба).*/
    E_CLR();                /*Строб.*/
}

/*Функция первоначальной установки разрядности шины
без проверки бита готовности.*/
void init_write(unsigned char data)
{
    /*Запись  в регистр команд.*/
    RS_IR();        /*Выбор регистра команд.*/
    RW_CLR();       /*Подача сигнала записи.*/

    E_SET();        /*Строб.*/
    DATA &= 0xFF00;
    DATA |= 0x00FF & data;
    _delay(1);      /*Задержка >230нс(минимальная длительность строба).*/
    E_CLR();        /*Строб.*/
}

/*Функция записи данных в графический контроллер.
Записываемые данные определяются аргументом data.*/
void data_write (unsigned char data)
{
    ctrl_ready(); /*Проверка флага занятости.*/

    /*Запись  в регистр команд(данных).*/
    RS_DR();        /*Выбор регистра данных.*/
    RW_CLR();       /*Подача сигнала записи.*/

    /*Старшая декада*/
    E_SET();        /*Строб.*/
    DATA &= 0xFF00;
    DATA |= 0x00FF & data;  /*Вывод в порт данных для записи.*/
    _delay(1);              /*Задержка >230нс(минимальная длительность строба).*/
    E_CLR();                /*Строб.*/
}

/*Функция инициализации ЖКИ.*/
void disp_init()
{
    /*Исходное состояние портов*/
    //DDATA |= 0x0F;    /*Порт данных на вывод.*/
    E_CLR();            /*Исходное состояние сигнала строба.*/
    //DCONTROL |= (1 << E) | (1 << RW) | (1 << RS); /*Линии управления на вывод.*/

    //начальная настройка модуля
    _delay_ms(40);/*Задержка после включения питания.*/
    init_write(0x30);   /*Запись разрядности шины, без проверки бита готовности.*/
    _delay(40);/*Задержка 40мкс.*/
    init_write(0x30);   /*Запись разрядности шины, без проверки бита готовности.*/
    _delay(40);/*Задержка 40мкс.*/
    init_write(0x30);   /*Запись разрядности шины, без проверки бита готовности.*/
    _delay(40);/*Задержка 40мкс.*/
    init_write(0x20);   /*Запись разрядности шины, без проверки бита готовности.*/
    _delay(40);/*Задержка 40мкс.*/

    //настройка индикатора
    /*Выбор ширины шины DL, числа линий  N, размера символа F и страницы знакогенератора P.*/
    cmd_write(0x20 | DL << 4 | N << 3 | F << 2 | P << 1);

    /*Сдвиг курсора или экрана SC, направление сдвиги RL.*/
    cmd_write(0x10 | SC << 3 | RL << 2);

    /*Выбор режима счетчика адреса ID,  режим сдвига экрана S.*/
    cmd_write(0x04 | ID << 1 | S);

    /*Включение дисплея и курсора.*/
    cmd_write(0x08 | D << 2 | C << 1 | B);

    disp_clr();
}

/*Функция выключения ЖК дисплея.*/
void disp_turn_off()
{
    /*Запись в регистр команд:
    выключение дисплея.*/
    cmd_write(0x08 | C << 1 | B);
}

/*Функция включения ЖК дисплея.*/
void disp_turn_on()
{
    /*Запись в регистр команд:
    включение дисплея.*/
    cmd_write(0x08 | 1 << 2 | C << 1 | B);
}

/*Функция установки позиции курсора.*/
static void disp_set_pos(uint8_t pos, uint8_t line)
{
    uint8_t adr;

    /*Установка адреса 0x00 если номер позиции выходит за пределы экрана.*/
    if (pos >= LCD_WIDTH)
    {
        cmd_write(0x80);
        return;
    }

    switch (line)
    {
        case 0:
            adr = pos;
            break;
        case 1:
            adr = 0x40 + pos;
            break;
        case 2:
            adr = 0x14 + pos;
            break;
        case 3:
            adr = 0x54 + pos;
            break;
        default:
            adr = 0x00;
    }

    cmd_write(0x80 | adr);/*Установка адреса курсора.*/
}

/*Функция вывода на дисплей символа.*/
void disp_put_char(uint8_t ch, uint8_t pos, uint8_t line)
{
    /*Установка позиции курсора.*/
    disp_set_pos(pos, line);
    /*Запись кода символа в память дисплея по текущему адресу курсора.*/
    data_write(ch);
}

/*Функция вывода на дисплей строки символов с переносом строки.*/
void disp_put_str(const char s[],uint8_t pos, uint8_t line)
{
    unsigned char i, pos_tmp, line_tmp;

    for (i = 0; s[i] != '\0'; i++)/*Вывод строки посимвольно до достижения кода конца строки.*/
    {
        pos_tmp = (i + pos) % (LCD_WIDTH);
        line_tmp = (i + pos) / (LCD_WIDTH);
        if ((pos_tmp == 0) && (line_tmp == 4))
            break;
        disp_set_pos(pos_tmp, line_tmp);
        data_write(s[i]);
    }
}

/*Функция вывода строки символов на одной строке без переноса.
В пределах одной строки индикатора работает быстрее функции put_str()
за счет автоматического инкремента позиции курсора графическим контроллером.*/
void disp_put_str_ln(const char s[], uint8_t pos, uint8_t line)
{
    uint8_t i;

    disp_set_pos(pos, line);/*Установка позиции курсора.*/
    for(i = 0; (s[i] != '\0') && ((i + pos) < LCD_WIDTH); i++)/*Вывод до достижения конца строки.*/
    {
        data_write(s[i]);
    }
}

/*Функция очистки дисплея.*/
void disp_clr()
{
    cmd_write(0x01);
    _delay_ms(2);//время исполнения команды 1.5 мс
}

/*Функция сброса счечика AC.*/
void disp_return_home()
{
    cmd_write(0x02);
}
